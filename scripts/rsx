#!/usr/bin/env python
import sys
from datetime import datetime
import click
from sqlalchemy.orm import joinedload, subqueryload
from pttt.timetable import parse_timetable, create_timetable, AbsoluteTime
import robostat.db as model
import robostat.rsx as rsx
from robostat.util import enumerate_rank

db = None

@click.group()
@click.option("-v", "--verbose", count=True) # sqlaparam käyttää tätä
@click.option("-d", "--db", type=rsx.SQLAParamType(session_args={"expire_on_commit": False}),
        envvar="ROBOSTAT_DB", required=True)
def rsx_group(**kwargs):
    global db
    db = kwargs["db"]

@rsx_group.command()
@click.option("-i", "--init", type=rsx.InitParamType(), envvar="ROBOSTAT_INIT", required=True)
@click.option("-r", "--print-ranking", multiple=True)
@click.option("-b", "--print-block", multiple=True)
def show(init, **kwargs):
    for r in kwargs["print_ranking"]:
        ranking = init.tournament.rankings[r](db)
        rsx.print_ranking(ranking)

    for b in kwargs["print_block"]:
        block = init.tournament.blocks[b]
        events = block.events_query(db)\
            .options(
                    subqueryload(model.Event.teams_part)
                    .joinedload(model.EventTeam.team, innerjoin=True),
                    subqueryload(model.Event.judgings)
                    .joinedload(model.EventJudging.judge, innerjoin=True),
                    subqueryload(model.Event.judgings)
                    .joinedload(model.EventJudging.scores, innerjoin=True)
            )\
            .all()

        rsx.print_events(block, events)

@rsx_group.command()
@click.option("-i", "--init", type=rsx.InitParamType(), envvar="ROBOSTAT_INIT")
def create(init):
    model.Base.metadata.create_all(db.engine)

@rsx_group.command("import")
@click.option("-f", "--file", type=click.File("r"), required=True)
@click.option("-b", "--block", required=True)
@click.option("-j", "--num_judges", "j",  default=1)
@click.option("-s", "--strict", is_flag=True)
@click.option("-y", "--no-confirm", "y", is_flag=True)
@click.option("-d", "--datefmt", default="%d.%m.%Y %H:%M")
def import_(strict, y, **kwargs):
    timetable = parse_timetable(kwargs["file"].read(), datefmt=kwargs["datefmt"])

    if not timetable:
        return

    k = len(timetable[0]) - kwargs["j"] - 1
    teams = set(timetable[:,1:1+k].labels)
    judges = set(timetable[:,1+k:].labels)

    teams = rsx.get_teams(db, teams, allow_insert=not strict, confirm=not y)
    judges = rsx.get_judges(db, judges, allow_insert=not strict, confirm=not y)

    teams = dict((t.name, t) for t in teams)
    judges = dict((j.name, j) for j in judges)

    # committaa tässä siltä jos lisättiin joukkueita/tuomareita
    # että niille saaadan id:t
    db.session.commit()

    events = []
    for e in timetable:
        event = model.Event(
            block_id=kwargs["block"],
            ts_sched=int(e.time),
            arena=e[0].name
        )
        event.team_ids.extend(teams[l.name].id for l in e[1:1+k])
        event.judge_ids.extend(judges[l.name].id for l in e[1+k:])
        events.append(event)

    click.echo("%s Insert %d events to block %s" % (
        click.style("[+]", fg="green", bold=True),
        len(events),
        kwargs["block"]
    ), err=True)

    db.session.add_all(events)
    db.session.commit()

@rsx_group.command()
@click.option("-b", "--block", required=True)
@click.option("--ids", is_flag=True)
def export(block, ids):
    events = db.query(model.Event)\
            .options(
                subqueryload(model.Event.teams_part)
                .joinedload(model.EventTeam.team, innerjoin=True),
                subqueryload(model.Event.judgings)
                .joinedload(model.EventJudging.judge, innerjoin=True)
            )\
            .filter(model.Event.block_id == block)\
            .order_by(model.Event.ts_sched)\
            .all()

    if ids:
        t_name = lambda team: "T%d" % team.id
        j_name = lambda judge: "J%d" % judge.id
    else:
        t_name = lambda team: team.name
        j_name = lambda judge: judge.name

    timetable = create_timetable(
        (
            AbsoluteTime(datetime.fromtimestamp(e.ts_sched)),
            [e.arena, *map(t_name, e.teams), *map(j_name, e.judges)]
        ) for e in events
    )

    print(timetable)

if __name__ == "__main__":
    rsx_group()
